#include "imgui_impl_deko3d.h"
#include "common/deko3d/context.h"
#include "common/deko3d/texture.h"
#include "imgui.h"
#include <stdio.h>

// Reusable buffers used for rendering 1 current in-flight frame, for ImGui_ImplDeko3D_RenderDrawData()
// [Please zero-clear before use!]
struct ImGui_ImplDeko3DH_FrameRenderBuffers
{
  Deko3D::MemoryHeap::Allocation VertexBuffer;
  Deko3D::MemoryHeap::Allocation IndexBuffer;
};

// Each viewport will hold 1 ImGui_ImplDeko3DH_WindowRenderBuffers
// [Please zero-clear before use!]
struct ImGui_ImplDeko3DH_WindowRenderBuffers
{
  uint32_t Index;
  uint32_t Count;
  ImGui_ImplDeko3DH_FrameRenderBuffers* FrameRenderBuffers;
};

// deko3D data
static ImGui_ImplDeko3D_InitInfo g_Deko3DInitInfo = {};
static Deko3D::MemoryHeap::Allocation g_UniformBuffer;
static Deko3D::MemoryHeap::Allocation g_DescriptorSet;
static Deko3D::MemoryHeap::Allocation g_SamplerSet;

// shaders
static Deko3D::MemoryHeap::Allocation g_VertShaderMemory;
static Deko3D::MemoryHeap::Allocation g_FragShaderMemory;
static dk::Shader g_VertShader;
static dk::Shader g_FragShader;

// Font data
static Deko3D::Texture g_FontTexture;
static Deko3D::MemoryHeap::Allocation g_FontTextureUploadBuffer;

// Render buffers
static ImGui_ImplDeko3DH_WindowRenderBuffers g_MainWindowRenderBuffers;

// Forward Declarations
bool ImGui_ImplDeko3D_CreateDeviceObjects();
void ImGui_ImplDeko3D_DestroyDeviceObjects();

//-----------------------------------------------------------------------------
// SHADERS
//-----------------------------------------------------------------------------

// glsl_shader.vert, compiled with:
// # uam --stage=vert --out=imgui_vert.dksh imgui_vsh.glsl
/*
#version 450 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aUV;
layout(location = 2) in vec4 aColor;

layout (std140, binding = 0)
uniform Transformation { vec2 uScale; vec2 uTranslate; } pc;

layout(location = 0) out struct { vec4 Color; vec2 UV; } Out;

void main()
{
    Out.Color = aColor;
    Out.UV = aUV;
    gl_Position = vec4(aPos * pc.uScale + pc.uTranslate, 0, 1);
}
*/
uint8_t vertShaderDksh[768] = {
  0x44, 0x4B, 0x53, 0x48, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x18, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x6F, 0x6C, 0x20, 0x6E, 0x76, 0x69, 0x64, 0x69, 0x61,
  0x20, 0x77, 0x68, 0x79, 0x20, 0x64, 0x69, 0x64, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x75,
  0x73, 0x20, 0x77, 0x61, 0x73, 0x74, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x00,
  0x61, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x20, 0xE4, 0x00, 0xB4, 0x1F, 0x00, 0x00, 0xFF, 0x07, 0x09, 0x80, 0xFF, 0xD8,
  0xEF, 0x02, 0xFF, 0x07, 0x08, 0x80, 0xFF, 0xD8, 0xEF, 0x04, 0x00, 0x27, 0x00, 0x88, 0x07, 0x98, 0x4C, 0xE1, 0x08,
  0x00, 0xFE, 0x02, 0x84, 0x1C, 0x00, 0x00, 0xFF, 0x07, 0x09, 0x80, 0xFF, 0xF0, 0xEF, 0x08, 0x02, 0x07, 0x00, 0x08,
  0x02, 0xA0, 0x49, 0x04, 0xFF, 0x07, 0x0A, 0x80, 0xFF, 0xD9, 0xEF, 0xEE, 0x07, 0x20, 0x3C, 0x02, 0x84, 0x1F, 0x00,
  0x02, 0x00, 0x37, 0x00, 0x88, 0x07, 0x98, 0x4C, 0x04, 0xFF, 0x07, 0x08, 0x80, 0xFF, 0xF1, 0xEF, 0x09, 0x03, 0x17,
  0x00, 0x08, 0x01, 0xA0, 0x49, 0xE1, 0x07, 0xC0, 0xFC, 0x00, 0x84, 0x0B, 0x00, 0x0A, 0x00, 0xF7, 0x0F, 0x80, 0x07,
  0x98, 0x5C, 0x0B, 0xF0, 0x07, 0x00, 0x00, 0xF8, 0x03, 0x01, 0x08, 0xFF, 0x07, 0x07, 0x80, 0xFF, 0xF1, 0xEF, 0xEF,
  0xFF, 0xE1, 0xFF, 0x00, 0x80, 0x1F, 0x00, 0x0F, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x0F, 0x00, 0x87, 0xFF,
  0xFF, 0x0F, 0x40, 0xE2, 0x00, 0x0F, 0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0xE0, 0x07, 0x00, 0xFC, 0x00, 0x80, 0x1F,
  0x00, 0x00, 0x0F, 0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x0F, 0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x0F,
  0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// glsl_shader.frag, compiled with:
// # uam --stage=frag --out=imgui_frag.dksh imgui_fsh.glsl
/*
#version 450 core
layout(location = 0) out vec4 fColor;
layout(binding=0) uniform sampler2D sTexture;
layout(location = 0) in struct { vec4 Color; vec2 UV; } In;
void main()
{
    fColor = In.Color * texture(sTexture, In.UV.st);
}
*/

uint8_t fragShaderDksh[768] = {
  0x44, 0x4B, 0x53, 0x48, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x18, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x7F, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x6F, 0x6C, 0x20, 0x6E, 0x76, 0x69, 0x64, 0x69, 0x61,
  0x20, 0x77, 0x68, 0x79, 0x20, 0x64, 0x69, 0x64, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x75,
  0x73, 0x20, 0x77, 0x61, 0x73, 0x74, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x00,
  0x62, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xAA, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0F, 0x07, 0xA0, 0xE1, 0x01, 0x04, 0x3C, 0x00, 0x00, 0xFF, 0xF7, 0xCF, 0x87, 0xFF, 0x03,
  0xE0, 0x04, 0x00, 0x47, 0x00, 0x00, 0x00, 0x80, 0x50, 0x00, 0xFF, 0x47, 0x00, 0x89, 0xFF, 0x43, 0xE0, 0x2F, 0x07,
  0x20, 0xE0, 0x03, 0xBC, 0x1C, 0x00, 0x01, 0xFF, 0x47, 0x40, 0x89, 0xFF, 0x43, 0xE0, 0x00, 0x00, 0x17, 0x20, 0x40,
  0x1A, 0x30, 0xD8, 0x05, 0xFF, 0x47, 0x00, 0x88, 0xFF, 0x43, 0xE0, 0xF0, 0x1F, 0xE0, 0xE1, 0x00, 0xC0, 0x3F, 0x00,
  0x00, 0x05, 0x07, 0x00, 0x00, 0x10, 0x68, 0x5C, 0x05, 0xFF, 0x47, 0x40, 0x88, 0xFF, 0x43, 0xE0, 0x01, 0x05, 0x17,
  0x00, 0x00, 0x10, 0x68, 0x5C, 0x0F, 0x07, 0x00, 0xFE, 0x01, 0x3C, 0x1C, 0x00, 0x05, 0xFF, 0x47, 0x80, 0x88, 0xFF,
  0x43, 0xE0, 0x02, 0x05, 0x27, 0x00, 0x00, 0x10, 0x68, 0x5C, 0x04, 0xFF, 0x47, 0xC0, 0x88, 0xFF, 0x43, 0xE0, 0xF0,
  0x0F, 0xE0, 0xFD, 0x3F, 0xFC, 0x1F, 0x00, 0x03, 0x04, 0x37, 0x00, 0x00, 0x10, 0x68, 0x5C, 0x0F, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x00, 0xE3, 0x0F, 0x00, 0x87, 0xFF, 0xFF, 0x0F, 0x40, 0xE2, 0xE0, 0x07, 0x00, 0xFC, 0x00, 0x80, 0x1F,
  0x00, 0x00, 0x0F, 0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x0F, 0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x0F,
  0x07, 0x00, 0x00, 0x00, 0xB0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

//-----------------------------------------------------------------------------
// FUNCTIONS
//-----------------------------------------------------------------------------

static void CreateOrResizeBuffer(Deko3D::MemoryHeap::Allocation& buffer, size_t new_size)
{
  if (buffer.size)
  {
    g_deko3d_context->GetGeneralHeap().Free(buffer);
  }

  buffer = g_deko3d_context->GetGeneralHeap().Alloc(new_size, 32);
}

static void ImGui_ImplDeko3D_SetupRenderState(ImDrawData* draw_data, dk::CmdBuf command_buffer,
                                              ImGui_ImplDeko3DH_FrameRenderBuffers* rb, int fb_width, int fb_height)
{
  command_buffer.bindShaders(DkStageFlag_GraphicsMask, {&g_VertShader, &g_FragShader});

  command_buffer.bindColorState(dk::ColorState{}.setBlendEnable(0, true));
  command_buffer.bindBlendStates(0, {dk::BlendState{}
                                       .setSrcColorBlendFactor(DkBlendFactor_SrcAlpha)
                                       .setDstColorBlendFactor(DkBlendFactor_InvSrcAlpha)
                                       .setSrcAlphaBlendFactor(DkBlendFactor_InvSrcAlpha)
                                       .setDstAlphaBlendFactor(DkBlendFactor_Zero)});
  command_buffer.bindColorWriteState(dk::ColorWriteState{}.setMask(0, DkColorMask_RGBA));
  command_buffer.bindRasterizerState(dk::RasterizerState{}.setCullMode(DkFace_None));

  command_buffer.bindDepthStencilState(dk::DepthStencilState{}.setDepthWriteEnable(false).setDepthTestEnable(false));

  // Bind Vertex And Index Buffer:
  command_buffer.bindVtxAttribState({
    DkVtxAttribState{0, 0, IM_OFFSETOF(ImDrawVert, pos), DkVtxAttribSize_2x32, DkVtxAttribType_Float, 0},
    DkVtxAttribState{0, 0, IM_OFFSETOF(ImDrawVert, uv), DkVtxAttribSize_2x32, DkVtxAttribType_Float, 0},
    DkVtxAttribState{0, 0, IM_OFFSETOF(ImDrawVert, col), DkVtxAttribSize_4x8, DkVtxAttribType_Unorm, 0},
  });
  command_buffer.bindVtxBufferState({{sizeof(ImDrawVert), 0}});

  // Setup viewport:
  command_buffer.setViewports(0, {{0.f, 0.f, (float)fb_width, (float)fb_height, 0.0f, 1.0f}});

  command_buffer.bindImageDescriptorSet(g_deko3d_context->GetGeneralHeap().GpuAddr(g_DescriptorSet), 32);
  command_buffer.bindSamplerDescriptorSet(g_deko3d_context->GetGeneralHeap().GpuAddr(g_SamplerSet), 1);

  // Setup scale and translation:
  // Our visible imgui space lies from draw_data->DisplayPps (top left) to draw_data->DisplayPos+data_data->DisplaySize
  // (bottom right). DisplayPos is (0,0) for single viewport apps.
  {
    float uniforms[4];
    // scale
    uniforms[0] = 2.0f / draw_data->DisplaySize.x;
    uniforms[1] = -2.0f / draw_data->DisplaySize.y;
    // translate
    uniforms[2] = -1.0f - draw_data->DisplayPos.x * uniforms[0];
    uniforms[3] = 1.0f - draw_data->DisplayPos.y * uniforms[1];
    command_buffer.pushConstants(g_deko3d_context->GetGeneralHeap().GpuAddr(g_UniformBuffer), g_UniformBuffer.size, 0,
                                 sizeof(uniforms), uniforms);
  }
  command_buffer.bindUniformBuffer(DkStage_Vertex, 0, g_deko3d_context->GetGeneralHeap().GpuAddr(g_UniformBuffer),
                                   g_UniformBuffer.size);
}

ImTextureID TextureIDs[32];
int NumTextureIDs;

static void ImGui_ImplDeko3D_UpdateAndBindDescriptors(const ImDrawCmd* pcmd, dk::CmdBuf command_buffer)
{
  /*int idx = -1;
  for (int i = 0; i < NumTextureIDs; i++)
  {
    if (TextureIDs[i] == pcmd->TextureId)
    {
      idx = i;
    }
  }
  if (idx == -1)*/
  {
    /*assert(NumTextureIDs < 32);
    idx = NumTextureIDs++;
    TextureIDs[idx] = pcmd->TextureId;*/
    const Deko3D::Texture* tex = static_cast<const Deko3D::Texture*>(pcmd->TextureId);

    //printf("binding texture %p %d %d\n", tex, tex->GetWidth(), tex->GetHeight());
    dk::ImageView view{tex->GetImage()};

    dk::ImageDescriptor descriptor;
    descriptor.initialize(view);
    command_buffer.barrier(DkBarrier_Full, DkInvalidateFlags_Descriptors);
    command_buffer.pushData(g_deko3d_context->GetGeneralHeap().GpuAddr(g_DescriptorSet)/*+idx*sizeof(descriptor)*/, &descriptor, sizeof(descriptor));
  }
  command_buffer.bindTextures(DkStage_Fragment, 0, {dkMakeTextureHandle(/*idx*/0, 0)});
}

// Render function
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from
// your main loop)
void ImGui_ImplDeko3D_RenderDrawData(ImDrawData* draw_data, dk::CmdBuf command_buffer)
{
  // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer
  // coordinates)
  int fb_width = (int)(draw_data->DisplaySize.x);
  int fb_height = (int)(draw_data->DisplaySize.y);
  if (fb_width <= 0 || fb_height <= 0 || draw_data->TotalVtxCount == 0)
    return;

  ImGui_ImplDeko3D_InitInfo* v = &g_Deko3DInitInfo;

  // Allocate array to store enough vertex/index buffers
  ImGui_ImplDeko3DH_WindowRenderBuffers* wrb = &g_MainWindowRenderBuffers;
  if (wrb->FrameRenderBuffers == NULL)
  {
    wrb->Index = 0;
    wrb->Count = v->ImageCount;
    wrb->FrameRenderBuffers =
      (ImGui_ImplDeko3DH_FrameRenderBuffers*)IM_ALLOC(sizeof(ImGui_ImplDeko3DH_FrameRenderBuffers) * wrb->Count);
    memset(wrb->FrameRenderBuffers, 0, sizeof(ImGui_ImplDeko3DH_FrameRenderBuffers) * wrb->Count);
  }
  IM_ASSERT(wrb->Count == v->ImageCount);
  wrb->Index = (wrb->Index + 1) % wrb->Count;
  ImGui_ImplDeko3DH_FrameRenderBuffers* rb = &wrb->FrameRenderBuffers[wrb->Index];

  // Create or resize the vertex/index buffers
  size_t vertex_size = draw_data->TotalVtxCount * sizeof(ImDrawVert);
  size_t index_size = draw_data->TotalIdxCount * sizeof(ImDrawIdx);
  if (rb->VertexBuffer.size < vertex_size)
    CreateOrResizeBuffer(rb->VertexBuffer, vertex_size);
  if (rb->IndexBuffer.size < index_size)
    CreateOrResizeBuffer(rb->IndexBuffer, index_size);

  // Upload vertex/index data into a single contiguous GPU buffer
  {
    ImDrawVert* vtx_dst = g_deko3d_context->GetGeneralHeap().CpuAddr<ImDrawVert>(rb->VertexBuffer);
    ImDrawIdx* idx_dst = g_deko3d_context->GetGeneralHeap().CpuAddr<ImDrawIdx>(rb->IndexBuffer);
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
      const ImDrawList* cmd_list = draw_data->CmdLists[n];
      memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
      memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
      vtx_dst += cmd_list->VtxBuffer.Size;
      idx_dst += cmd_list->IdxBuffer.Size;
    }
  }

  command_buffer.bindVtxBuffer(0, g_deko3d_context->GetGeneralHeap().GpuAddr(rb->VertexBuffer), rb->VertexBuffer.size);
  command_buffer.bindIdxBuffer(sizeof(ImDrawIdx) == 2 ? DkIdxFormat_Uint16 : DkIdxFormat_Uint32,
                               g_deko3d_context->GetGeneralHeap().GpuAddr(rb->IndexBuffer));

  // Setup desired Deko3D state
  ImGui_ImplDeko3D_SetupRenderState(draw_data, command_buffer, rb, fb_width, fb_height);

  // Will project scissor/clipping rectangles into framebuffer space
  ImVec2 clip_off = draw_data->DisplayPos; // (0,0) unless using multi-viewports

  // Render command lists
  // (Because we merged all buffers into a single one, we maintain our own offset into them)
  int global_vtx_offset = 0;
  int global_idx_offset = 0;
  for (int n = 0; n < draw_data->CmdListsCount; n++)
  {
    const ImDrawList* cmd_list = draw_data->CmdLists[n];
    for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
    {
      const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
      if (pcmd->UserCallback != NULL)
      {
        // User callback, registered via ImDrawList::AddCallback()
        // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to
        // reset render state.)
        if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
          ImGui_ImplDeko3D_SetupRenderState(draw_data, command_buffer, rb, fb_width, fb_height);
        else
          pcmd->UserCallback(cmd_list, pcmd);
      }
      else
      {
        // Project scissor/clipping rectangles into framebuffer space
        ImVec4 clip_rect;
        clip_rect.x = (pcmd->ClipRect.x - clip_off.x);
        clip_rect.y = (pcmd->ClipRect.y - clip_off.y);
        clip_rect.z = (pcmd->ClipRect.z - clip_off.x);
        clip_rect.w = (pcmd->ClipRect.w - clip_off.y);

        if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0f && clip_rect.w >= 0.0f)
        {
          ImGui_ImplDeko3D_UpdateAndBindDescriptors(pcmd, command_buffer);

          // Negative offsets are illegal for vkCmdSetScissor
          if (clip_rect.x < 0.0f)
            clip_rect.x = 0.0f;
          if (clip_rect.y < 0.0f)
            clip_rect.y = 0.0f;

          // Apply scissor/clipping rectangle
          command_buffer.setScissors(0,
                                     {{(uint32_t)(clip_rect.x), (uint32_t)(clip_rect.y),
                                       (uint32_t)(clip_rect.z - clip_rect.x), (uint32_t)(clip_rect.w - clip_rect.y)}});
          // Draw
          command_buffer.drawIndexed(DkPrimitive_Triangles, pcmd->ElemCount, 1, pcmd->IdxOffset + global_idx_offset,
                                     pcmd->VtxOffset + global_vtx_offset, 0);
        }
      }
    }
    global_idx_offset += cmd_list->IdxBuffer.Size;
    global_vtx_offset += cmd_list->VtxBuffer.Size;
  }
}

bool ImGui_ImplDeko3D_CreateFontsTexture(dk::CmdBuf command_buffer)
{
  ImGui_ImplDeko3D_InitInfo* v = &g_Deko3DInitInfo;
  ImGuiIO& io = ImGui::GetIO();

  unsigned char* pixels;
  int width, height;
  io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
  size_t upload_size = width * height * 4 * sizeof(char);

  g_FontTexture.Create(width, height, 1, 0, DkImageFormat_RGBA8_Unorm, DkMsMode_1x, DkImageType_2D, 0);

  g_FontTextureUploadBuffer = g_deko3d_context->GetGeneralHeap().Alloc(upload_size, DK_IMAGE_LINEAR_STRIDE_ALIGNMENT);
  memcpy(g_deko3d_context->GetGeneralHeap().CpuAddr<void>(g_FontTextureUploadBuffer), pixels, upload_size);

  g_FontTexture.UpdateFromBuffer(command_buffer, 0, 0, 0, 0, width, height,
                                 g_deko3d_context->GetGeneralHeap().GpuAddr(g_FontTextureUploadBuffer));

  // Store our identifier
  io.Fonts->TexID = (ImTextureID)(intptr_t)&g_FontTexture;
  io.Fonts->ClearTexData();

  return true;
}

struct DkshHeader
{
  uint32_t magic;     // DKSH_MAGIC
  uint32_t header_sz; // sizeof(DkshHeader)
  uint32_t control_sz;
  uint32_t code_sz;
  uint32_t programs_off;
  uint32_t num_programs;
};

void LoadShader(const uint8_t* data, Deko3D::MemoryHeap::Allocation& gpuMem, dk::Shader& out)
{
  DkshHeader header;
  memcpy(&header, data, sizeof(DkshHeader));

  gpuMem = g_deko3d_context->GetShaderHeap().Alloc(header.code_sz, DK_SHADER_CODE_ALIGNMENT);
  memcpy(g_deko3d_context->GetShaderHeap().CpuAddr<void>(gpuMem), &data[header.control_sz], header.code_sz);

  dk::ShaderMaker{g_deko3d_context->GetShaderHeap().GetMemBlock(), gpuMem.offset}
    .setControl(data)
    .setProgramId(0)
    .initialize(out);
}

bool ImGui_ImplDeko3D_CreateDeviceObjects()
{
  ImGui_ImplDeko3D_InitInfo* v = &g_Deko3DInitInfo;

  // Create The Shader Modules:
  if (g_SamplerSet.size == 0)
  {
    dk::Sampler sampler;
    sampler.setFilter(DkFilter_Linear, DkFilter_Linear);
    sampler.setWrapMode(DkWrapMode_Repeat, DkWrapMode_Repeat);

    g_SamplerSet =
      g_deko3d_context->GetGeneralHeap().Alloc(sizeof(dk::SamplerDescriptor), DK_SAMPLER_DESCRIPTOR_ALIGNMENT);

    g_deko3d_context->GetGeneralHeap().CpuAddr<dk::SamplerDescriptor>(g_SamplerSet)->initialize(sampler);
  }

  if (g_DescriptorSet.size == 0)
  {
    g_DescriptorSet =
      g_deko3d_context->GetGeneralHeap().Alloc(sizeof(dk::ImageDescriptor)*32, DK_IMAGE_DESCRIPTOR_ALIGNMENT);
  }

  if (g_VertShaderMemory.size == 0)
  {
    LoadShader(vertShaderDksh, g_VertShaderMemory, g_VertShader);
  }
  if (g_FragShaderMemory.size == 0)
  {
    LoadShader(fragShaderDksh, g_FragShaderMemory, g_FragShader);
  }

  if (g_UniformBuffer.size == 0)
  {
    g_UniformBuffer = g_deko3d_context->GetGeneralHeap().Alloc(4 * sizeof(float), DK_UNIFORM_BUF_ALIGNMENT);
  }

  return true;
}

void ImGui_ImplDeko3D_DestroyFontUploadObjects()
{
  ImGui_ImplDeko3D_InitInfo* v = &g_Deko3DInitInfo;

  if (g_FontTextureUploadBuffer.size != 0)
  {
    g_deko3d_context->GetGeneralHeap().Free(g_FontTextureUploadBuffer);
  }
}

void ImGui_ImplDeko3D_DestroyDeviceObjects()
{
  ImGui_ImplDeko3D_InitInfo* v = &g_Deko3DInitInfo;
  ImGui_ImplDeko3D_DestroyFontUploadObjects();

  g_FontTexture.Destroy(false);
}

bool ImGui_ImplDeko3D_Init(ImGui_ImplDeko3D_InitInfo* info)
{
  // Setup back-end capabilities flags
  ImGuiIO& io = ImGui::GetIO();
  io.BackendRendererName = "imgui_impl_deko3D";
  io.BackendFlags |=
    ImGuiBackendFlags_RendererHasVtxOffset; // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

  g_Deko3DInitInfo = *info;
  ImGui_ImplDeko3D_CreateDeviceObjects();

  return true;
}

void ImGui_ImplDeko3D_Shutdown()
{
  ImGui_ImplDeko3D_DestroyDeviceObjects();
}
